<!--
	page_number:true
-->

Въведение в Haskell
Основни Типове
==


---

## Какво е Haskell

 - стриктно типуван
 - (lazy) pure functional language
 - c кратък, странен, но елегантен и удобен синтаксис

---

## Деклариране на променливи

```hs
i :: Int
i = 3

c :: Char
c = 'c'

d :: Double
d = 3.0
```

---

## Анатомия на дефинициите - сигнатурата


```hs
i :: Int
```

 - деклариране на променлива `i`
 - `::` оператор, който означава _има тип_
 - самият тип - Int

---

## Анатомия на дефинициите - променливата


```hs
i = 3
i = 4 -- compiltime error
```

 - в Haskell променливите не са промнливи, а дефиниция или псевдоним към стойност - един път зададена стойност на променлива, тя не може да бъде мутирана или повторно задавана
 - операторът за присвояване е `=`

---

## Type Inference

Haskell сам може да открие типовете, без да му бъдат подадени. Програмата винаги е добре типувана (дори при изпуснати сигнатури) и ако има грешки или двусмислие ще бъдат хванати при компилация.

```hs
c' = 'e' -- inferred as Char
```

**Добра практика**: винаги пишете сигнатурите на всички не-вгнездени дефиниции

---

## Основни типове

<br>

| Тип                        | Стойности              |
|----------------------------|------------------------|
| Boolean                    | `True`, `False`        |
| Int (32/64 bit)            | `0`, `1`, `2`, `3`, .. |
| Double                     | `0.0`, `0.5`, `1.33`   |
| Char                       | `'a'`, `'b'`, `'c'`    |
| Integer - произволно голям | `1234567890123456789..`       |

<br>**Забележка:** Синтаксисът на езика изисква типовете винаги да започват с главна буква. Променливите (било то константи или имена на функции), задължително започват с малка.

---

## Именоване на променливи

 - винаги започват с малка буква
 - състоят се от unicode букви, цифри и символът `'`
 - символът `'` (секонд) се използва са повторна/спомагателна дефиниция
 - по конвенция се ползва camelCase пред snake_case

 ```hs
fairRandom = 4

diceRoll   = 6
diceRoll'  = 3

theZCharacter = 'z'
```

---

## Операции върху числа

Аритметичните операции са в голямата си част както в другите езици и притежават обичайните свойства - `+`, `-`, `*`

```hs
> 3 + 4 * 5
-- 3 + (4 * 5)
23

> 1 + (-2) - 3
0
```

<br>**Hint:** Обграждайте отрицателните числа в скоби (пр. `(-2)`). В противен случай на много места компилаторът ще се оплаква със странни грешки.

___

## Целочислено деление

Делението на цели числа става посредством функциите `div` и `quot`:

```hs
> quot 10 5
2

> quot (-4) 3
-1

> div (-4) 3
-2
```

**Hint:** използвайте `quot` за (интуитивно) поведение като в C. Разликата между двата операторa е само при деление на числа с различни знаци.

---

## Нецелочислено деление

Операторът за нецелочислено деление е познатият `/`
```hs
> 3 / 4
0.75

> (-5) / 2
-2.5

> 10 / 2.5
4.0
```

---

## Работa с функции - извикване

 - извикването на функция става без скоби
 - параметрите се подавата в реда, в който функцията ги очаква, разделени с празно (whitespace)
 - извикването на функция е операцията с най-висок приоритет
 - ако е нужна промяна на приоритета се използват скоби

```hs
quot 4 2
> 2

quot 20 2 * 5
  -- (quot 20 2) * 5
> 50

quot 20 (2 * 5)
  -- quot 20 10
> 2
```

---

## Сигнатура на функция

```hs
quot :: Int -> Int -> Int
  |      |      |      |
 name   arg1   arg2  result
```

Сигнатурата на функция предсталява изброени аргументите, които тя приема последвани от резултатния тип, всички елемнети разделени със знака `->` помежду им.

**Как се чете:** `quot` е функция която приема два аргумнта от тип `Int` и връща като резултат `Int`.

---

```hs
parseNumber :: String -> Int
```

Е функция която приема `String` и връща `Int`.
<br>

```hs
mishmash :: Int -> Boolean -> String -> CustomType
```
```hs
> mishmash 10 False "string"
-- some value of type CustomType
```

---

## Дефиниране на функция

Синтаксис:
```hs
funtionName arg1 arg2 argN = definition
```

<br>Пример:
```hs
add3 :: Int -> Int -> Int -> Int
add3 x y z = x + y + z
```

---

## Декларативен стил - Pattern Matching

Hasekell набляга на така наречение декларативен стил на програмиране. Целта е имплементиране на функциите като дефиниции за различни случаи, а не като поредица от действия. Този подход прилича много на часовете по математика, където се описват какви са свойствата на дадена функция.

Средството, което се Haskell предоставя, се нарича pattern matching.

---

ПР: формулата за функцията на Fibonacci е:
<pre>
F<sub>0</sub> = 0
F<sub>1</sub> = 1
F<sub>n</sub> = F(n-1) + F(n-2)
</pre>

<br>Транслирана в код на Haskell:
```hs
fib :: Int -> Int
fib 0 = 0
fib 1 = 1
fib n = fib (n - 1) + fib (n - 2)
```

---

```hs
fib :: Int -> Int
fib 0 = 0
fib 1 = 1
fib n = fib (n - 1) + fib (n - 2)
```

<br>`fib 0`, `fib 1` правят pattern matching по съответна стойност. `0` и `1` са patterns - съответните константи.
<br>`fib n` - тук pattern е именоването на входа, т.е. декларираме че всеки друг вход ще наричаме `n`. Или погледнато по-просто, казваме че входът е променливата `n`, ако не е някой от предходните случаи.

---

<br>**Важно:** Отделните patterns се проверяват в реда, в който са дефинирани.

ПР:
```hs
encodeBoolean :: Int -> Int
encodeBoolean 0 = 0
encodeBoolean n = 1

encodeBoolean' :: Int -> Int
encodeBoolean' n = 1
encodeBoolean' 0 = 0
```

```hs
> encodeBoolean 0
0

> encodeBoolean' 0
1
```

---

## Декларативнен стил - guards

В Haskell (и останалите функционални езици) липсват _statements_ (твърдения). Програмите се изграждат като вгнездени _expressions_ (изрази). Изразите винаги връщат резултат, за разлика от твърденията, чието основно предназначение е извършване на страничен ефект.

Това прави използването на конструкции като `if` неудобни, понеже задължително трябва да бъде съпроводен от `else` и двата клона да продуцират резултат. Идиоматичният Haskell използва механизъм, много подобен на Допустими Стойности като синтаксис, който едновременно решава горния проблем и предоставя приятен външен вид.

---

## Пример - guards

Формулата за функцията на Fibonacci, ДС стил:
<pre>
       ┃ 0                <i>ако n == 0</i>
ƒ(n) = ┫ 1                <i>ако n == 1</i>
       ┃ ƒ(n-1) + ƒ(n-2)  <i>ако n > 1</i>
</pre>

<br>Транслирана в код на Haskell:
```hs
fib :: Int -> Int
fib n | n == 0 = 0
      | n == 1 = 1
      | n >  1 = fib (n - 1) + fib (n - 2)
```

---

## Пример 2 - signum

<br>Използването на guards е особено удобно, когато pattern matching не е възможен.

<br>

```hs
signum :: Int -> Int
signum x | x < 0  = -1
         | x == 0 = 0
         | x > 0  = 1
```

---

## Пример 3 - преразгледан fib

Крайното условие на guards е препоръчително да е най-общият случай, като преди това са проверени конкретните изключения. Обикновено се ползва константата `otherwise`, но тя е просто псевдоним за `True`.

<br>Дефиниция на `fib`, която поддържа и отрицателни числа:
```hs
fib' :: Int -> Int
fib' n | n <= 0    = 0
       | n == 1    = 1
       | otherwise = fib' (n - 1) + fib' (n - 2)
```

---

## guards - генерализиран синтаксис

```hs
funName param
    | bool-condition       = specific-definition
     ....
    | bool-condition-n     = specific-definition-n
    | otherwise            = most-general-definition
```

<br>**Забележка:** Критично важно е правилното подравняване! Компилаторът използва индентацията като маркер, че дефиницията на функцията продължава!

