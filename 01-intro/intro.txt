Да започваме директно - Какво е функционално програмиране? Очевидно е програмиране с функции.Tова сега не е много съдържателен отговор. Всъщност няма някаква общоприета дефиниция на функционално програмиране, но пък шегата, че е програмиране с функции не е толкова далеч от истината. Въпросът е, че тези функции са почти като математически обекти. Какво имам предвид? Ами извикани с едни и същи аргументи, връщат винаги една и съща стойност. Това нещо се нарича рефенциална прозрачност - изчислението на функцията не зависи в/у някакъв контекст или вътрешно състояние, а само върху аргументите. Имаме само рекурсия, нямаме цикли Функциите, Друго - нямаме 'истински' променливи - веднъж просвоение, не може да променяме стойността. Мислете си за променливите за етикет на дадена стойност, а не чекмедже или клетка в паметта. Още - immutability - веднъж създадена, не може да променяме някаква структура от данни. Например, ако искаме да увеличим първия елемент на масив с 1, ще се наложи да копираме оригиналния масив. Освен това, нещо повече, ако странните ограничения досега не са ви достатъчни -  функциите в Хаскелл са чисти/pure/ или без странични ефекти, не пипат глобални променливи, не си променят аргументите, не записват в някаква обща памет, не четат от нищо и не пишат по нищо, те просто и единствено смятат някакви неща. Как това е толкова яко? Ами улеснява много, вие не трябва да мислите за скрити състояния, правите по-малко бъгове, пишете много по-малко, по-продуктивни сте като свикнете, може по-лесно да си представяте как се изчислява програмата (мислено да се правите на дебъгер)- заради refential transparency-to може просто да замените извикването на функция с резултата и (защо в С не може).  Не се притеснявайте за производителност компилаторът е страшно умен, може да споделя еднаквите части на обектите без да ги копира.

И всъщност е това е. Обаче нещо понамирисвате, не мислите ли? Едва ли съм ви убедил колко яко е да не може да ползвате половината неща, с които сте свикнали. Вие не живете в страх от скрито състояние на програмата, обикновено не се правите на ментален дебъгер, как всички тези сравнително произволни ограничения ви помагат на Вас? Te всъщност помагат на компилатора - като няма странични ефекти той може да размества функциите, да ги обединява, да гененрира по-добър код, но това как ви прави по-продуктвни? Получава се лека абсурдна ситуация - няма как това да са причните, които до водят до тези следствия, а следствията са верни. 

Реално това, което прави даден език мощен, експресивен са инструментите за структуриране, които предоставя. Колко лесно може да модулизирате проблема си? Това сте го чували доста пъти. По-малко внимание се обръща на това как различните подпроблеми могат да си взаимодействат един с друг? Това зависи от самия език. Функционалното програмиране предоставя много добро такова 'лепило'. Във функционалните езици самите функции са стойности като всяка друга в езика и може да ги предаваме като аргументи и връщаме като резултат. Функциите, които приемат други функции като аргументи се наричат функции от по-висок ред. Те се генерилизарт много лесно и са страхотно лепило между отделните части на задачата.

За пример може да погледнем QuickSort - не знам дали се сещате как работи, на нас като ни го преподаваха в Туес ни дадоха някаква много страшна имплементация с много индекси и цикли. Идеята е супер просто - харесвате си произволен елемент, слагате го там където трябва да бъде във все едно сортирания списък - тоест всички по-малки или равни елементи са пред него, всички по-големи - след него, и извиквате рекурсивно за двете така образували се подчасти. Това се превежда директно в Haskell.

Другото добро средство за структуриране, което функционалното езици могат да дадат и специално Haskell, e мързиловото изчисляване. Резултатът от функциите не се изчислява, докато не е необходим. Тъпа аналогия - представете си, че си седите в стаята и майка ви ви вика да изхвърлите боклука, купите вода и почистите секцията. Естествено не правите нищо. Казва ви, че баща ви си идва след 10 мин и всичко е готово за 5 мин. Ето това е мързеливо изчисляване. Сега как това изобщо може да се използва за разделяне на различните проблеми.

Примерът е малко измислен, за да е простичък. Представете си, че искате да направите някаква пълна дивотия - например да смятате числата на фибоначи (днес ще ви доповръща от тях, ще ги използваме много), та от числата на фибоначи, смятате ги и вземете първите 5 нечетни. Някаква глупост. Стандартното решение в императивен език е да извъртите някакъв цикъл, ще проверявате дали е нечетно и ако е - да го пъхате в някакъв списък. Съгласете се, ще има някакви if-ове и няма да е ясно от пръв поглед. Как би изглеждало това в lazy функционален език - бихте генерирали числата на фибоначи, ще филтрирате за нечетните и накрая ще вземете 10. С lazy може много добре да разделим логиката на изцяло отделно блокове, не смесваме различните ни аспекти на изчислението. Само една бърза вметка - мързеливото изчисляване не е възможно със странични ефекти - резултатите са абсолютно непредсказуеми тогава. Виждате как нещата се напсват - като цяло програмирането с функционални езици прилича много на лего.

--Булшит алърт--
И сега последно нещо за функционалното програмиране - statement vs expression - това е леко разводнена терминология, всеки си я разбира интиутивно или пък не я разбира изобщо - и това е валиден вариант. Ще се опитам да представим лаишко обяснение - със statement казвате на машината какво да направи, с expression казвате какво да изчисли. От expression-а очаквате някаква стойност, от statement-а някакво действие. В рамките на един Statement може да участват няколко expression-a или други statement-i. Например if (i<3) then print ++i; else i = i*2; Императивните програми са последователност от statement-i, функционалните пък - от expression-и. По-неабстрактен пример - Колко е 2+3? (това е еxpression - питам ви за резултат) Извадете си листче, извадете си химикалки и сметнете колко е 2+3 - това е statement, описвам ви някакво действие. (Сега може да спорите, че и при първи пример смятането е дейстие.)
-- --

Сега малко за историята - всичко започва грубо преди около 120 години. Тогава хората започват да се чудят какво е изчисление, кои неща изобщо могат да бъдат пресметнати, с какво да извършваме тези изчисления, как може да се автоматизират. Математиците се опитват формализират някакви идеи, примерно се чудят дали рекурсията е валидна форма на изчисление, дали изобщо е коректно да се използва такова нещо. (А сега го приемаме за даденост, но преди около 100 години изобщо не е било така. Пишат се едни теореми и доказателства за рекурсията - втората казва, че съществува програма, която може да изпринтира сорс кода си във всеки език - quine). Около 1940 се появява един такъв модел за изчисления - ламбда смятането - изобщо няма да влизаме в детайли какво е това, но в него са много важни функциите и прилагането на функции. Реално това се явява прадядото на модерното функционално програмиране. През 1958 се появава Lisp, един от първите езици от високо ниво и първият функционален език. Той имплементира напрактика идеите на lambda смятането. След това хората се опитват да доказват някакви неща, до които са стигнали с Lisp, заиграват се неуспешно с компютърни архитектури - все пак компютърът е бил новост и са искали да го променят, че да отговоря по близо до идеите на ФП. От друга страна в този период се появава и С, които има доста по-успешна връзка с хардуера и някак си функционалното програмиране минава леко на заден план. На преден план излиза отново в края на 80, Бакус изнася лекция, в която хвали много Фп като практическо средство, а не само като някакво математическа играчка. В този период много хора от университетите започват да експериментират с lazy функционални езици, за около 15 години се нарояват дузина. Стават толкова много, че хората, които се занимават с ФП, решават, че трябва да има един общ. И през 1988 започват дискусии по мейлинг листи, реално се създава нещо като комитет, който да разработва езика и две години по-късно, на 1.04.1990 излиза първата версия на Хаскел; не е първоаприлска шега. Нали няма конкретен човек, който го е измислил, общи усилия са, не е като Python или Ruby. По-стар е от Python, от Java, от Ruby и постоянно расте и се развива. Oт 1992 до 2011, например, кодът на самия компилатор се е увеличил от 28к реда до 140к.

Защо се казва Хаскел? Кръстен е Хаскел Къри, математик, живял 20 век, направил е всъщност нещо доста яко - той е намерил аналогия между математиката и компютърните науки, успял е да трансферира идеите от едното в другото. Защо това е ценно? Ами (смислена) математика има кажи речи от около 2300 години, а тогава компютърните науки се били още прохождащи с бебешки стъпки. Математиката е пълна с ценни идеи и резултати, които бързо са намерили аналог в КН. Това е принципно вярно в които и да е науки -  когато се установи такова съотвествие между две сфери, по-младата може да напредне с много бързи темпове.

И една забавна история - когато са се спряли на това име, двама души от комитета отиват при вдовицата на Хаскел Къри, тя е още жива и я питат дали е съгласна да кръстят език за програмиране на него. Тя е, все пак е някакъв вид почест и дори отива на една от първите лекции за Haskell в някой университет. Естествено не разбира нищо и накрая на лекцията споделя, че всъщност мъжът и изобщо не си харесвал името. Така че Хаскел е кръстен на човек, който мразел как се казва.

В крайна сметка защо мисля, че функционалното програмиране е важно -  дори да не пишете на Хаскел, което е вероятно, дори да не използвате изобщо функционалното програмиране, мисля, че е много ценно просто да видите тези идеи, за да знаете какво може да се появи в следващата версия на езика ви. Има миграция на идеи от функционалното програмиране към императивното. Напрактика във всеки един  език има (нещо като) функции от по-висок ред вече. В Java в ги вкараха едва преди няколко години и това е защото хората осъзнават, че са удобни.  Мисля, че е много полезно да сте имали експозиция към тях, ако решите да се занимавате с такъв език - супер, но дори и да не го направите със сигурност не е загуба на време.
