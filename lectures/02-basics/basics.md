<!--
    page_number:true
    *page_number:false
-->

Въведение в Haskell<br/>Основен синтаксис и типове
==

<br>
<br>
<br>

Георги Наков, [nakov.gl at gmail com](mailto:nakov.gl+tues@gmail.com)  
Марин Маринов, [marinov.ms+tues at gmail com](mailto:marinov.ms+tues@gmail.com)

Технологично училище "Електронни Системи"  
19 Октомври 2016г.

---

## Какво е Haskell

 - стриктно типуван
 - (lazy) pure functional language
 - с кратък, странен, но елегантен и удобен синтаксис

---

## Деклариране на променливи

```hs
i :: Int
i = 3

c :: Char
c = 'c'

d :: Double
d = 3.0
```

---

## Анатомия на дефинициите - сигнатурата


```hs     
i :: Int
```

 - деклариране на променлива `i`
 - `::` оператор, който означава _има тип_
 - самият тип - Int

---

## Анатомия на дефинициите - променливата


```hs    
i = 3
i = 4 -- compile-time error
```

 - в Haskell променливите не са "променливи", а дефиниция или наименование на стойност - един път зададена такава, тя не може да бъде мутирана или повторно задавана
 - операторът за присвояване е `=`

---

## Type Inference

Haskell сам може да открие типовете, без да му бъдат подадени. Програмата винаги е добре типувана (дори при изпуснати сигнатури) и ако има грешки или двусмислие ще бъдат хванати при компилация.
<br>

```hs
c' = 'e' -- inferred as Char
```

<br>**Добра практика**: винаги пишете сигнатурите на всички не-вгнездени дефиниции

---

## Основни типове

| Тип                        | Стойности               |
|----------------------------|-------------------------|
| Bool                       | `True`, `False`         |
| Int (32/64 bit)            | `0`, `1`, `2`, `3`, ..  |
| Double                     | `0.0`, `0.5`, `1.33`    |
| Char                       | `'a'`, `'b'`, `'c'`     |
| Integer - произволно голям | `1234567890123456789..` |

<br>**Забележка:** Синтаксисът на езика изисква типовете винаги да започват с главна буква. Променливите (било то константи или имена на функции), задължително започват с малка.

---

## Именоване на променливи

 - винаги започват с малка буква
 - състоят се от unicode букви, цифри и символът `'`
 - символът `'` (секонд) се използва са повторна/спомагателна дефиниция
 - по конвенция се ползва camelCase пред snake_case
<br>

```hs
fairRandom = 4

diceRoll   = 6
diceRoll'  = 3

theZCharacter = 'z'
```

---

## Булеви алгебра

Haskell използва познатите оператори за логическите операции.

`&&` - логическо и  
`||` - логическо или  
`not` - логическо отрицание, не е оператор, а функция

<br>

```hs
> True && False
False

> True || False
True

> not True
False
```

---

## Оператори за сравнение


| Оператор | Значение            |
|----------|---------------------|
| `==`     | равно / еднакво     |
| `/=`     | неравно / различно  |
| `<`      | по-малко            |
| `>`      | по-голямо           |
|`<=`      | по-малко или равно  |
|`>=`      | по-голямо или равно |


<br>**Забележка:** Сравнителните оператори в Haskell са същите като в повечето други езици, с изключение на различно - `/=`.

---

## Операции върху числа

Аритметичните операции са в голямата си част както в другите езици и притежават обичайните свойства - `+`, `-`, `*`

```hs
> 3 + 4 * 5
-- 3 + (4 * 5)
23

> 1 + (-2) - 3
0
```

<br>**Hint:** Обграждайте отрицателните числа в скоби (пр. `(-2)`). В противен случай на много места компилаторът ще се оплаква със странни грешки.

---

## Целочислено деление

Делението на цели числа става посредством функциите `div` и `quot`:

```hs
> quot 10 5
2

> quot (-4) 3
-1

> div (-4) 3
-2
```

<br>**Hint:** използвайте `quot` за (интуитивно) поведение като в C. Разликата между двата операторa е само при деление на числа с различни знаци.

---

## Нецелочислено деление

Операторът за нецелочислено деление е познатият `/`
```hs
> 3 / 4
0.75

> (-5) / 2
-2.5

> 10 / 2.5
4.0
```

---

## Работа с функции - извикване

 - извикването на функция става без скоби
 - параметрите се подават в реда, в който функцията ги очаква, разделени с празно (whitespace)
 - извикването на функция е операцията с най-висок приоритет
 - ако е нужна промяна на приоритета се използват скоби

```hs
> quot 4 2
2

> quot 20 2 * 5
  -- (quot 20 2) * 5
50

> quot 20 (2 * 5)
  -- quot 20 10
2
```

---

## Сигнатура на функция

```hs     
quot :: Int -> Int -> Int
  |      |      |      |
 name   arg1   arg2  result
```

Сигнатурата на функция представлява изброени аргументите, които тя приема, последвани от резултатния тип, разделени със знака `->` помежду им.

**Как се чете:** `quot` е функция която приема два аргумента от тип `Int` и връща като резултат `Int`.

---
## Сигнатура на функция
<br>

```hs     
parseNumber :: String -> Int
```

Е функция която приема `String` и връща `Int`.
<br>

```hs     
mishmash :: Int -> Bool -> String -> CustomType

> mishmash 10 False "string"
-- some value of type CustomType
```

---

## Дефиниране на функция
<br>

Синтаксис:
```hs     
funtionName arg1 arg2 argN = definition
```

<br>Пример:
```hs
add3 :: Int -> Int -> Int -> Int
add3 x y z = x + y + z

> add3 100 1000 (-1)
1099
```

---
## Дефиниране на частни случаи

Може да имаме отделни случаи (с различно тяло) за конкретни стойности на аргументите на функция.
<br>
```hs
guessTheNumber :: Int -> String
guessTheNumber 42 = "Got it right, pal!"
guessTheNumber  x = "Try again"
```

---
## Дефиниране на частни случаи...

Наподобяват много на `if`. Какво печелим?
- много четим и лесен за разбиране код
- пишем по-малко
- декларативен стил
- логическо отделяне на *по-специалните* случаи (*corner cases* - *ако аргументът е нула, ако низът е празен, ако масивът няма елементи*)

---

## Дефиниране на частни случаи...

Формулата за функцията на Fibonacci е:
<pre>
F<sub>0</sub> = 0
F<sub>1</sub> = 1
F<sub>n</sub> = F(n-1) + F(n-2)
</pre>

<br>Транслирана в код на Haskell:
```hs
fib :: Int -> Int
fib 0 = 0
fib 1 = 1
fib n = fib (n - 1) + fib (n - 2)
```

---

## Дефиниране на частни случаи...

Работят и за функции с повече от един аргумент:
```
grades :: Int -> Int -> String
grades 2      2        = "Absolute zero!"
grades theory 2        = "Solve more problems!"
grades 2      practice = "Study more!"
grades theory practice = "Passable!"
```
Проверяват се линейно - от първия ред към последния; ако има съвпадение, се изпълнява само тялото за конкретния случай, т.е **редът има значение!**
Дефиницията само с променливи е възможно най-генералният случай.

---

## Списъци (*a.k.a листове*)

<br>
Едносвързаният списък е основна структура във функционалните езици.
<br><br>
<p align="center">
  <img src="./linked-list.png" width="650"/>
</p>

Защо списък?
 - евтино, без мутация добавяне в началото
 - натурално приляга на рекурсивни решения

---

## Списъци - синтаксис

Наподобяват много масивите от императивните езици!


- празен списък
```hs
emptyList :: [Int]
emptyList = []
```
- непразен списък
``` hs
listOfNums :: [Int]
listOfNums = [1, 2, 3, 4]
```

<br>**Важно**: Типът **не е `Int[]`**, а е **`[Int]`**!

---

## Списъци - добавяне на елемент

Операцията по добавяне на нов елемент отпред на списъка е се нарича `cons`. Произлиза от думата `construct` и е наследство от Lisp - първият език, който ги вкарва в масова употреба.

Haskell притежава удобен синтаксис - `value : list` (":" се чете cons)
```hs
> 1 : [2, 3, 4]
[1, 2, 3, 4]

> 1 : 2 : 3 : 4 : []
[1, 2, 3, 4]
```

---

## Списъци...

Когато използваме ":" многократно, скоби не са нужни.  
*(или казваме, че `cons` е дясно асоциативна и с нисък приоритет)*


```hs
> 1:2:3:4:[]       == [1, 2, 3, 4]
True

> 1:(2:(3:(4:[]))) == [1, 2, 3, 4]
True

> 1 + 2 : 3 : quot 4 2 : []
  -- (1 + 2) : 3 : (quot 4 2) : []
[3, 3, 2]

```

<br>**Важно:** Всъщност синтаксисът `[1, 2, 3, 4]` е само удобство (_syntactic sugar_), който компилаторът свежда до `1:2:3:4:[]`.

---

## Списъци - други операции

Трите базови операции върху едносвързан списък са:
 - добавяне на елемент в началото (`cons`, `:`)
 - проверка дали списъкът е празен (`[]`)
 - разделяне на списъка на глава и останала част
   ```hs
   x : xs <-- останала част (също е списък)
   |   
   глава
   ```
**Важно:** Записът `x:xs` - списък с поне един елемент `х`. `xs` е списък с останалите елементи (или празен - `[]`).
`[x, xs]` - списък с точно два елемента `x` и `xs`!

---


## Типът String

Типът `String` е просто списък от символи - `[Char]`. Логически е доста близък до този в C, с разликата, че в Haskell не е null терминиран масив, а едносвързан списък.

<br>

```hs
str :: String
str = "string"

str' :: [Char]
str' = "string"

str'' :: [Char]
str'' = 's':'t':'r':'i':'n':'g':[]

> str == str' && str == str''
True
```

---

## Pattern matching

- декларативен стил на програмиране. 
- целта е имплементиране на функциите като дефиниции за различни случаи, а не като поредица от действия.
- задаваме *шаблон*, срещу който се съпоставят входните данни (аргументите) на функцията:  
  - ако има съвпадение - изпълняваме тялото; 
  - ако не - продължваме надолу със следващия *шаблон* (ако има) или приключваме без резултат.  

Средството, което Haskell предоставя, се нарича pattern matching.

---

## Pattern matching...

- генерализация на частните случаи на функции
- *шаблонът* - дефинира структурата на данните, тества как са били създадани 
- допълнително ни дава възможност да *деконструираме* сложна стойност - да вземем отделни подчасти в нея като променливи
- при прости типове - съвпада с частните случаи
- при сложни типове (списък)....

---

## Pattern matching - прости типове ...

```hs     
fib :: Int -> Int
fib 0 = 0
fib 1 = 1
fib n = fib (n - 1) + fib (n - 2)
```

<br>`fib 0`, `fib 1` правят pattern matching по съответна стойност. `0` и `1` са patterns - съответните константи.
<br>`fib n` - тук pattern е именоването на входа, т.е. декларираме че всеки друг вход ще наричаме `n`. Или погледнато по-просто, казваме че входът е променливата `n`, ако не е някой от предходните случаи.

---

## Pattern matching - листове

Два основни шаблона за тестване:
- `[]` - празен списък
-  (x:xs) - списък с първи елемент `x`
<br>

```hs
restOrEmpty :: [Int] -> [Int]
restOrEmpty []     = []
restOrEmpty (x:xs) = xs

firstOrDefault :: Int -> [Int] -> Int
firstOrDefault def []     = def -- empty list
firstOrDefault def (x:xs) = x
```
<!--
  lecturer note:
    - `firstOrDefault` vs `head`
    - `restOrEmpty` vs `tail`
  
  ask students what do they expect from
  head :: [Int] -> Int
-->

---

## Пример - дължина на списък

Дължина на списък:
```hs
intListLength :: [Int] -> Int
intListLength []     = 0
intListLength (x:xs) = 1 + intListLength xs

> intListLength []
0

> intListLength [1, 2, 3, 4]
4
```

<br>**Hint:** Haskell има вградена функция за изчисляване дължината на списък от произволен тип - `length`.


---

## Работа със списъци

Много чест прийом при работата със списъци е:
```hs
work [] = []
work (x:xs) = f x : (work xs)
```
<br>

### Пример - числа на квадрат
```hs
squared :: [Int]->[Int]
squared [] = []
squared (x:xs) = (x^2) : (squared xs)
```

---


## Pattern matching

Шаблоните могат да се влагат! Те не са ограничени до едно ниво - с тях могат да се създават произволни комбинации!

<br>

```hs
-- Look a list of lists of Int
isFirstDoubleZeroArray :: [[Int]] -> Bool
isFirstDoubleZeroArray ([0,0] : rest) = True
isFirstDoubleZeroArray xs             = False

isThird42 :: [Int] -> Bool
isThird42 (x:y:42:rest)  = True
isThird42 xs             = False
```

---

## Pattern matching - wildcard

В случаите, в които не ползваме променливата, е желателно да я именоваме `_`. `_` е специален pattern, който се тълкува като "игнорирай" или "не ме интересува". Само по себе си това не звучи много полезно, но помага на компилатора в създаване на по-лесно разбираеми диагностични съобщения и предпазване от механични грешки.
<br>

```hs
intToBool :: Int -> Bool
intToBool 0 = False
intToBool _ = True   -- everything other than 0
                     -- (we don't care exactly what)
```

---


## Guards

- наподобяват pattern matching
- за разлика от тях не тестват *структурата* на стойността, а някакво свойство; оценяват се до `True` или `False`
- отново пдопомогат декларативния стил, правят кодът по-четим и лесен и заместват `if`
---

## Пример - guards

```hs
ageism :: Int -> String
ageism x 
  | x < 2     = "Babyyyy!"
  | x < 10    = "Stay wild, child!"
  | x < 20    = "You're a rebel!"
  | otherwise = "You're a serious grown-up!"
```

Крайното условие на guards е препоръчително да е най-общият случай, като преди това са проверени конкретните изключения. Обикновено се ползва константата `otherwise`, но тя е просто псевдоним за `True`.


---

## Пример 2 - signum

Използването на guards е особено удобно, когато pattern matching не е възможен.

<br>

```hs
signum :: Int -> Int
signum x | x < 0  = -1
         | x == 0 = 0
         | x > 0  = 1
```
**Важно**: Забележете, че `=` стои след guard-а.

---


## guards - генерализиран синтаксис

```hs     
funName param
    | bool-condition    = specific-definition
     ....
    | bool-condition-n  = specific-definition-n
    | otherwise         = most-general-definition
```

<br>**Важно:** Критично важно е правилното подравняване! Компилаторът използва индентацията като маркер, че дефиницията на функцията продължава!

---

## Pattern matching и guards

Могат да се ползват заедно

```
isThirdEven :: [Int] -> Bool
isThirdEven (x:y:z:rest) | even z       = True
isThirdEven x            | length x > 2 = False
```

Ненапълно вярна функция, защото е непълнa. Какво става, ако я извикаме с `[1,2]` или `[]`

```text
Pattern match(es) are non-exhaustive
    In an equation for ‘isThirdEven’:
        Patterns not matched:
```

---


## Pattern matching и guards - strings

```hs
isKey :: String -> Bool
isKey "key"    = True
isKey ('K':xs) = True
isKey _        = False

reverseKeys :: String -> String
reverseKeys (x:y:z:rest)
    | isKey (x:y:z:[]) = z:y:x:(reverseKeys rest)

reverseKeys (x:rest)   = x : reverseKeys rest
reverseKeys []         = []

> reverseKeys "This is a Killer key"
"This is a liKler yek"
```

---

## GHCi

Това е интерактивен Haskell REPL. Повечето програми, които ще пишем, няма да компилираме до executables, а ще ги използваме през GHCi с цел по-лесна, интерактивна и бърза работа. Haskell е известен с относително сложния си модел на IO. Нека това не ви безпокои, нито отказва. Ще стигнем до там, но преди това трябва да се заредим с по-базовите средства и концепции :)

---

## GHCi - команди

`:l <source_path>` - служи за зареждане на сорс файла достъпен на съответния път

```text
:l Demo.hs
[1 of 1] Compiling Demo ( Demo.hs, interpreted )
Ok, modules loaded: Demo.
```

<br>`:r` - презареждане на вече заредени сорсове
```text
:r
[1 of 1] Compiling Demo ( Demo.hs, interpreted )
Ok, modules loaded: Demo.
```

---

## GHCi - команди

`:t <expression>` - показва типа на съответния _expression_

```text
> :t True
True :: Bool

> :t 10
10 :: Num a => a

> :t (2 + 2)
(2 + 2) :: Num a => a

> :t words
words :: String -> [String]
```

---

**Важно:** не се притеснявайте, че типът на числата не е `Int`, а `Num a => a`. Това е генерализиран тип за число. Не се плашете и от малките букви! В следващите няколко урока ще стигнем до тях - с времето и вие ще станете тъмни магьосници, но първо трябва да минем базовите неща!

---

## GHCi - команди

`:i <identifier>` - показа информация за дадената променлива с име _identifier_, какъв й е типът и къде е дефинирана

<br>

```text
> :i words

words :: String -> [String]
  	-- Defined in ‘base-4.8.2.0:Data.OldList’
```

---

## GHCi - други полезни команди

Тези команди са общовалидни за терминала и са част от така нареченият emacs mode. Повечето приложения, които има някаква форма на интеракция, използват именно тези shortcuts.

---

| Команда  | Използване                                  |
|----------|---------------------------------------------|
| tab      | допълване / completion                      |
| Ctrl + r | reverse search - търси в историята на вече въвежданите команди |
| Ctrl + a | изместване на курсора в началото на реда    |
| Ctrl + e | изместване на курсора в края на реда        |
| Ctrl + w | изтриване на думата, при/преди курсора      |
| Ctrl + d | спира текущия shell / command line програма |
| Ctrl + l | почиства екрана                             |

---

## GHCi - последни думи

Не използвайте GHCi за големи дефиниции (примерно на функции). GHCi не работи добре за въвеждане на многоредов код, затова е препоръчително кодът да е във файл, а в GHCi само да бъде презареждан и отделните функции тествани. Разглеждане на типове, малки експерименти и тестове са силните страни на всеки REPL.
